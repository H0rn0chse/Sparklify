{
  "version": 3,
  "sources": [
    "../src/Sparkle.ts",
    "../src/utils.ts",
    "../src/SparkleAnimation.ts"
  ],
  "sourcesContent": [
    "// Sparkles from https://www.joshwcomeau.com/react/animated-sparkles-in-react/\r\nconst path =\r\n  \"M26.5 25.5C19.0043 33.3697 0 34 0 34C0 34 19.1013 35.3684 26.5 43.5C33.234 50.901 34 68 34 68C34 68 36.9884 50.7065 44.5 43.5C51.6431 36.647 68 34 68 34C68 34 51.6947 32.0939 44.5 25.5C36.5605 18.2235 34 0 34 0C34 0 33.6591 17.9837 26.5 25.5Z\";\r\n\r\nexport class Sparkle {\r\n  #root: HTMLDivElement = document.createElement(\"div\");\r\n  size: string;\r\n  color: string;\r\n\r\n  constructor(size: string, color: string) {\r\n    this.size = size;\r\n    this.color = color;\r\n\r\n    this.#createHtml();\r\n  }\r\n\r\n  #createHtml(): void {\r\n    this.#root.classList.add(\"sparklify-sparkleWrapper\");\r\n    this.#root.style.width = this.size;\r\n\r\n    const outerSparkle = document.createElement(\"div\");\r\n    outerSparkle.classList.add(\"sparklify-outerSparkle\");\r\n    outerSparkle.style.width = this.size;\r\n\r\n    const innerSparkle = document.createElementNS(\r\n      \"http://www.w3.org/2000/svg\",\r\n      \"svg\"\r\n    );\r\n    innerSparkle.setAttribute(\"viewBox\", \"0 0 68 68\");\r\n    innerSparkle.innerHTML = `<path d=\"${path}\" fill=\"${this.color}\"/>`;\r\n    innerSparkle.classList.add(\"sparklify-innerSparkle\");\r\n    innerSparkle.style.width = this.size;\r\n\r\n    outerSparkle.appendChild(innerSparkle);\r\n    this.#root.appendChild(outerSparkle);\r\n  }\r\n\r\n  getDomRef(): HTMLDivElement {\r\n    return this.#root;\r\n  }\r\n\r\n  destroy(): void {\r\n    this.#root.remove();\r\n  }\r\n}\r\n",
    "export function randomMinMax (min: number, max: number): number {\r\n  return Math.random() * (max - min) + min;\r\n}\r\n\r\nexport function parseCssSize(size: string): { value: number; unit: string } {\r\n  const regex = /^([\\d.]+)([a-z%]+)$/i;\r\n  const match = size.match(regex);\r\n  if (!match) {\r\n    throw new Error(`Invalid CSS size: ${size}`);\r\n  }\r\n\r\n  return {\r\n    value: parseFloat(match[1]),\r\n    unit: match[2],\r\n  };\r\n} \r\n",
    "import { Sparkle } from \"./Sparkle\";\r\nimport { randomMinMax } from \"./utils\";\r\n\r\nexport interface SparkleAnimationOptions {\r\n  target: HTMLElement;\r\n  size?: string;\r\n  colors?: string[];\r\n  animationLength?: number;\r\n  initialDelay?: number;\r\n  pauseMin?: number;\r\n  pauseMax?: number;\r\n}\r\n\r\nexport class SparkleAnimation {\r\n  private target: HTMLElement;\r\n  private size: string;\r\n  private colors: string[];\r\n  private animationLength: number;\r\n  private initialDelay: number;\r\n  private pauseMin: number;\r\n  private pauseMax: number;\r\n  private animationLengthMin: number;\r\n  private animationLengthMax: number;\r\n  private isRunning: boolean = false;\r\n  private isPaused: boolean = false;\r\n  private animationController: AbortController = new AbortController();\r\n  private resolveAfterStop: ((value: unknown) => void) | undefined = undefined;\r\n\r\n  constructor(options: SparkleAnimationOptions) {\r\n    this.target = options.target;\r\n    this.size = options.size ?? \"1.2rem\";\r\n    this.colors = options.colors ?? [\"yellow\", \"white\", \"gold\", \"orange\"];\r\n    this.animationLength = options.animationLength ?? 700;\r\n    this.initialDelay = options.initialDelay ?? 0;\r\n    this.pauseMin = options.pauseMin ?? 100;\r\n    this.pauseMax = options.pauseMax ?? 500;\r\n    this.animationLengthMin = this.animationLength;\r\n    this.animationLengthMax = this.animationLength * 1.6;\r\n  }\r\n\r\n  private wait(ms: number, signal?: AbortSignal): Promise<void> {\r\n    return new Promise((resolve, reject) => {\r\n      const timeout = setTimeout(resolve, ms);\r\n      if (signal) {\r\n        signal.addEventListener(\"abort\", () => {\r\n          clearTimeout(timeout);\r\n          reject(new DOMException(\"Aborted\", \"AbortError\"));\r\n        });\r\n      }\r\n    });\r\n  }\r\n\r\n  private async runSparkle(animationLength: number): Promise<void> {\r\n      const color = this.colors[Math.floor(Math.random() * this.colors.length)];\r\n      const sparkle = new Sparkle(this.size, color);\r\n\r\n      const domRef = sparkle.getDomRef();\r\n      domRef.style.top = Math.random() * 100 + \"%\";\r\n      domRef.style.left = Math.random() * 100 + \"%\";\r\n      domRef.style.setProperty(\"--animation-length\", `${animationLength}ms`);\r\n      \r\n      if (Math.random() < 0.3) { // 30% chance to render behind content\r\n        domRef.style.zIndex = \"-1\";\r\n      } else {\r\n        domRef.style.zIndex = \"2\";\r\n      }\r\n\r\n      // handle abort\r\n      this.animationController.signal.addEventListener(\"abort\", () => {\r\n        sparkle.destroy();\r\n      });\r\n\r\n      this.target.insertAdjacentElement(\"afterbegin\", domRef);\r\n\r\n      try {\r\n        await this.wait(animationLength, this.animationController.signal);\r\n      } catch {}\r\n      sparkle.destroy();\r\n  }\r\n\r\n  private async animate(): Promise<void> {\r\n    this.isPaused = true;\r\n    try {\r\n      await this.wait(this.initialDelay, this.animationController.signal);\r\n    } catch {\r\n      return;\r\n    }\r\n    this.isPaused = false;\r\n\r\n    while (this.isRunning) {\r\n      const randomAnimationLength = randomMinMax(this.animationLengthMin, this.animationLengthMax);\r\n      await this.runSparkle(randomAnimationLength);\r\n      \r\n      if (this.resolveAfterStop) {\r\n        this.resolveAfterStop(null);\r\n      }\r\n\r\n      if (!this.isRunning) {\r\n        break;\r\n      };\r\n      \r\n      this.isPaused = true;\r\n      const pauseDuration = randomMinMax(this.pauseMin, this.pauseMax);\r\n      try {\r\n        await this.wait(pauseDuration, this.animationController.signal);\r\n      } catch {\r\n        break;\r\n      }\r\n      this.isPaused = false;\r\n    }\r\n  }\r\n\r\n  start(): void {\r\n    if (this.isRunning) {\r\n      return;\r\n    }\r\n    this.isRunning = true;\r\n\r\n    this.animationController.signal.addEventListener(\"abort\", () => {\r\n      this.isRunning = false;\r\n    });\r\n\r\n    this.animate();\r\n  }\r\n\r\n  stop(): void {\r\n    this.animationController.abort();\r\n    this.animationController = new AbortController();\r\n  }\r\n\r\n  async stopOnceDone(): Promise<void> {\r\n    if (!this.isRunning || this.isPaused) {\r\n      this.stop();\r\n      return;\r\n    }\r\n\r\n    const stopOnceDoneDeferred = Promise.withResolvers();\r\n    this.resolveAfterStop = stopOnceDoneDeferred.resolve;\r\n    await stopOnceDoneDeferred.promise;\r\n    this.resolveAfterStop = undefined;\r\n    this.stop();\r\n  }\r\n}"
  ],
  "mappings": "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",
  "names": [
    "path",
    "Sparkle",
    "#root",
    "size",
    "color",
    "#createHtml",
    "outerSparkle",
    "innerSparkle",
    "randomMinMax",
    "min",
    "max",
    "SparkleAnimation",
    "options",
    "ms",
    "signal",
    "resolve",
    "reject",
    "timeout",
    "animationLength",
    "color",
    "sparkle",
    "Sparkle",
    "domRef",
    "randomAnimationLength",
    "randomMinMax",
    "pauseDuration",
    "stopOnceDoneDeferred"
  ]
}
