{
  "version": 3,
  "sources": ["../src/utils.ts", "../src/Sparkle.ts", "../src/SparkleAnimation.ts", "../src/webcomponent/AnimationHandler.ts", "../src/webcomponent/index.ts"],
  "sourcesContent": ["export function randomMinMax (min: number, max: number): number {\n  return Math.random() * (max - min) + min;\n}\n\nexport function parseCssSize(size: string): { value: number; unit: string } {\n  const regex = /^([\\d.]+)([a-z%]+)$/i;\n  const match = size.match(regex);\n  if (!match) {\n    throw new Error(`Invalid CSS size: ${size}`);\n  }\n\n  return {\n    value: parseFloat(match[1]),\n    unit: match[2],\n  };\n} \n", "// Sparkles from https://www.joshwcomeau.com/react/animated-sparkles-in-react/\nconst path =\n  \"M26.5 25.5C19.0043 33.3697 0 34 0 34C0 34 19.1013 35.3684 26.5 43.5C33.234 50.901 34 68 34 68C34 68 36.9884 50.7065 44.5 43.5C51.6431 36.647 68 34 68 34C68 34 51.6947 32.0939 44.5 25.5C36.5605 18.2235 34 0 34 0C34 0 33.6591 17.9837 26.5 25.5Z\";\n\nexport class Sparkle {\n  #root: HTMLDivElement = document.createElement(\"div\");\n  size: string;\n  color: string;\n\n  constructor(size: string, color: string) {\n    this.size = size;\n    this.color = color;\n\n    this.#createHtml();\n  }\n\n  #createHtml(): void {\n    this.#root.classList.add(\"sparkleWrapper\");\n    this.#root.style.width = this.size;\n\n    const outerSparkle = document.createElement(\"div\");\n    outerSparkle.classList.add(\"outerSparkle\");\n    outerSparkle.style.width = this.size;\n\n    const innerSparkle = document.createElementNS(\n      \"http://www.w3.org/2000/svg\",\n      \"svg\"\n    );\n    innerSparkle.setAttribute(\"viewBox\", \"0 0 68 68\");\n    innerSparkle.innerHTML = `<path d=\"${path}\" fill=\"${this.color}\"/>`;\n    innerSparkle.classList.add(\"innerSparkle\");\n    innerSparkle.style.width = this.size;\n\n    outerSparkle.appendChild(innerSparkle);\n    this.#root.appendChild(outerSparkle);\n  }\n\n  getDomRef(): HTMLDivElement {\n    return this.#root;\n  }\n\n  destroy(): void {\n    this.#root.remove();\n  }\n}\n", "import { Sparkle } from \"./Sparkle\";\nimport { randomMinMax } from \"./utils\";\n\nexport interface SparkleAnimationOptions {\n  target: HTMLElement;\n  size?: string;\n  colors?: string[];\n  animationLength?: number;\n  initialDelay?: number;\n  pauseMin?: number;\n  pauseMax?: number;\n}\n\nexport class SparkleAnimation {\n  private target: HTMLElement;\n  private size: string;\n  private colors: string[];\n  private animationLength: number;\n  private initialDelay: number;\n  private pauseMin: number;\n  private pauseMax: number;\n  private animationLengthMin: number;\n  private animationLengthMax: number;\n  private isRunning: boolean = false;\n  private isPaused: boolean = false;\n  private animationController: AbortController = new AbortController();\n  private resolveAfterStop: ((value: unknown) => void) | undefined = undefined;\n\n  constructor(options: SparkleAnimationOptions) {\n    this.target = options.target;\n    this.size = options.size ?? \"1.2rem\";\n    this.colors = options.colors ?? [\"yellow\", \"white\", \"gold\", \"orange\"];\n    this.animationLength = options.animationLength ?? 700;\n    this.initialDelay = options.initialDelay ?? 0;\n    this.pauseMin = options.pauseMin ?? 100;\n    this.pauseMax = options.pauseMax ?? 500;\n    this.animationLengthMin = this.animationLength;\n    this.animationLengthMax = this.animationLength * 1.6;\n  }\n\n  private wait(ms: number, signal?: AbortSignal): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout(resolve, ms);\n      if (signal) {\n        signal.addEventListener(\"abort\", () => {\n          clearTimeout(timeout);\n          reject(new DOMException(\"Aborted\", \"AbortError\"));\n        });\n      }\n    });\n  }\n\n  private async runSparkle(animationLength: number): Promise<void> {\n      const color = this.colors[Math.floor(Math.random() * this.colors.length)];\n      const sparkle = new Sparkle(this.size, color);\n\n      const domRef = sparkle.getDomRef();\n      domRef.style.top = Math.random() * 100 + \"%\";\n      domRef.style.left = Math.random() * 100 + \"%\";\n      domRef.style.setProperty(\"--animation-length\", `${animationLength}ms`);\n      \n      if (Math.random() < 0.3) { // 30% chance to render behind content\n        domRef.style.zIndex = \"-1\";\n      } else {\n        domRef.style.zIndex = \"2\";\n      }\n\n      // handle abort\n      this.animationController.signal.addEventListener(\"abort\", () => {\n        sparkle.destroy();\n      });\n\n      this.target.insertAdjacentElement(\"afterbegin\", domRef);\n\n      try {\n        await this.wait(animationLength, this.animationController.signal);\n      } catch {}\n      sparkle.destroy();\n  }\n\n  private async animate(): Promise<void> {\n    this.isPaused = true;\n    try {\n      await this.wait(this.initialDelay, this.animationController.signal);\n    } catch {\n      return;\n    }\n    this.isPaused = false;\n\n    while (this.isRunning) {\n      const randomAnimationLength = randomMinMax(this.animationLengthMin, this.animationLengthMax);\n      await this.runSparkle(randomAnimationLength);\n      \n      if (this.resolveAfterStop) {\n        this.resolveAfterStop(null);\n      }\n\n      if (!this.isRunning) {\n        break;\n      };\n      \n      this.isPaused = true;\n      const pauseDuration = randomMinMax(this.pauseMin, this.pauseMax);\n      try {\n        await this.wait(pauseDuration, this.animationController.signal);\n      } catch {\n        break;\n      }\n      this.isPaused = false;\n    }\n  }\n\n  start(): void {\n    if (this.isRunning) {\n      return;\n    }\n    this.isRunning = true;\n\n    this.animationController.signal.addEventListener(\"abort\", () => {\n      this.isRunning = false;\n    });\n\n    this.animate();\n  }\n\n  stop(): void {\n    this.animationController.abort();\n    this.animationController = new AbortController();\n  }\n\n  async stopOnceDone(): Promise<void> {\n    if (!this.isRunning || this.isPaused) {\n      this.stop();\n      return;\n    }\n\n    const stopOnceDoneDeferred = Promise.withResolvers();\n    this.resolveAfterStop = stopOnceDoneDeferred.resolve;\n    await stopOnceDoneDeferred.promise;\n    this.resolveAfterStop = undefined;\n    this.stop();\n  }\n}", "import { SparkleAnimation } from \"../SparkleAnimation\";\nimport { parseCssSize, randomMinMax } from \"../utils\";\n\nexport class AnimationHandler {\n  private count: number = 3;\n  private colors: string[] = [\"yellow\", \"white\", \"gold\", \"orange\"];\n  private size: string = \"1.2rem\";\n  private speed: number = 1000;\n  private target: HTMLElement | null = null;\n  private initialized: boolean = false;\n  private animations: SparkleAnimation[] = [];\n  private isUpdating: boolean = false;\n  private pendingUpdate: boolean = false;\n\n  setCount(count: number): void {\n    this.count = count;\n    this.scheduleUpdate();\n  }\n\n  setColors(colors: string[]): void {\n    this.colors = colors;\n    this.scheduleUpdate();\n  }\n\n  setSize(size: string): void {\n    this.size = size;\n    this.scheduleUpdate();\n  }\n\n  setSpeed(speed: number): void {\n    this.speed = speed;\n    this.scheduleUpdate();\n  }\n\n  private scheduleUpdate(): void {\n    if (!this.initialized) return;\n    if (this.isUpdating) {\n      this.pendingUpdate = true;\n      return;\n    }\n    this.updateAnimations();\n  }\n\n  async updateAnimations(initialRun: boolean = false): Promise<void> {\n    if (!this.target) return;\n\n    this.isUpdating = true;\n    this.pendingUpdate = false;\n\n    if (!initialRun) {\n      await Promise.all(this.animations.map(async (animation) => {\n        await animation.stopOnceDone();\n      }));\n  \n      // Clear the animations array\n      this.animations = [];\n    }\n\n    // Create new animations based on current settings\n    let initialDelay = 0;\n    const sizeDetails = parseCssSize(this.size);\n\n    for (let i = 0; i < this.count; i++) {\n      const speedAndSizeFactor = randomMinMax(0.5, 1);\n      const animation = new SparkleAnimation({\n        target: this.target,\n        size: `${sizeDetails.value * speedAndSizeFactor}${sizeDetails.unit}`,\n        colors: this.colors,\n        animationLength: this.speed * speedAndSizeFactor,\n        initialDelay: initialDelay, // staggered start\n      });\n      animation.start();\n      this.animations.push(animation);\n\n      initialDelay += randomMinMax(100, 300);\n    }\n\n    this.isUpdating = false;\n\n    // If there was a pending update, process it now\n    if (this.pendingUpdate) {\n      await this.updateAnimations();\n    }\n  }\n\n  async init(target: HTMLElement): Promise<void> {\n    this.target = target;\n    this.initialized = true;\n    await this.updateAnimations(true);\n  }\n\n  destroy(): void {\n    this.animations.forEach((animation) => animation.stop());\n    this.animations = [];\n    this.target = null;\n  }\n}\n", "import { parseCssSize } from \"../utils\";\nimport { AnimationHandler } from \"./AnimationHandler\";\n\nconst styleTemplate = document.createElement(\"template\");\nstyleTemplate.innerHTML = \"<style>STYLE_CONTENT_PLACEHOLDER</style>\";\n\nclass Sparklify extends HTMLElement {\n  private handler: AnimationHandler = new AnimationHandler();\n\n  static get observedAttributes() {\n    return [\"count\", \"colors\", \"size\", \"speed\"];\n  }\n\n  connectedCallback() { \n    // Create a shadow root\n    const shadowRoot = this.attachShadow({ mode: \"open\" });\n    \n    const styleElement = styleTemplate.content.cloneNode(true);\n    shadowRoot.appendChild(styleElement);\n\n    const slot = document.createElement(\"slot\");\n    slot.addEventListener(\"slotchange\", () => {\n      this.handler.updateAnimations();\n    });\n    const defaultSlowWrapper = document.createElement(\"div\");\n    defaultSlowWrapper.style.position = \"relative\";\n    defaultSlowWrapper.appendChild(slot);\n    shadowRoot.appendChild(defaultSlowWrapper);\n\n    const options = {\n      count: parseInt(this.getAttribute(\"count\") || \"0\", 10) || 3,\n      colors: this.getAttribute(\"colors\")?.split(\",\") || [\n        \"yellow\",\n        \"white\",\n        \"gold\",\n        \"orange\",\n      ],\n      size: this.getAttribute(\"size\") || \"20px\",\n      speed: parseInt(this.getAttribute(\"speed\") || \"0\", 10) || 1000,\n    };\n\n    this.handler.setCount(options.count);\n    this.handler.setColors(options.colors);\n    this.handler.setSize(options.size);\n    this.handler.setSpeed(options.speed);\n\n    this.handler.init(defaultSlowWrapper);\n  }\n\n  disconnectedCallback() {\n    // Clean up animations when element is removed\n    this.handler.destroy();\n  }\n\n  attributeChangedCallback(\n    name: string,\n    oldValue: string | null,\n    newValue: string | null,\n  ) {\n    if (newValue == undefined || oldValue === newValue) {\n      return;\n    }\n\n    switch (name) {\n      case \"count\":\n        this.setCount(parseInt(newValue, 10));\n        break;\n      case \"colors\":\n        this.setColors(newValue.split(\",\"));\n        break;\n      case \"size\":\n        try {\n          parseCssSize(newValue);\n        } catch (error) {\n          console.error(error);\n          return;\n        }\n\n        this.setSize(newValue);\n        break;\n      case \"speed\":\n        this.setSpeed(parseInt(newValue, 10));\n        break;\n\n      default:\n        throw new Error(`The property ${name} is not supported`);\n    }\n  }\n\n  setCount(count: number) {\n    this.handler.setCount(count);\n    this.setAttribute(\"count\", count.toString());\n  }\n\n  setColors(colors: string[]) {\n    this.handler.setColors(colors);\n    this.setAttribute(\"colors\", colors.join(\",\"));\n  }\n\n  setSize(size: string) {\n    this.handler.setSize(size);\n    this.setAttribute(\"size\", size);\n  }\n\n  setSpeed(speed: number) {\n    this.handler.setSpeed(speed);\n    this.setAttribute(\"speed\", speed.toString());\n  }\n}\n\nwindow.customElements.define(\"sparklify-content\", Sparklify);\n"],
  "mappings": "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",
  "names": ["randomMinMax", "min", "max", "parseCssSize", "size", "regex", "match", "path", "Sparkle", "#root", "size", "color", "#createHtml", "outerSparkle", "innerSparkle", "SparkleAnimation", "options", "ms", "signal", "resolve", "reject", "timeout", "animationLength", "color", "sparkle", "Sparkle", "domRef", "randomAnimationLength", "randomMinMax", "pauseDuration", "stopOnceDoneDeferred", "AnimationHandler", "count", "colors", "size", "speed", "initialRun", "animation", "initialDelay", "sizeDetails", "parseCssSize", "speedAndSizeFactor", "randomMinMax", "SparkleAnimation", "target", "styleTemplate", "Sparklify", "AnimationHandler", "shadowRoot", "styleElement", "slot", "defaultSlowWrapper", "options", "name", "oldValue", "newValue", "parseCssSize", "error", "count", "colors", "size", "speed"]
}
